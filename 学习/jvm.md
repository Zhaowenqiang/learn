### jvm学习笔记

#### 1、什么是虚拟机
 - jvm实际上就是将操作系统的底层实现和Java字节码之间进行了一次解耦
#### 2、jvm有哪些部分组成
 - 类加载器
 - 运行时数据区
   - 方法区
   - 堆
   - Java栈
   - 本地方法栈
   - 程序计数器
 - 执行引擎
 - 本地接口
 - 本地库
#### 3、执行引擎的作用
 - 执行引擎负责执行class文件中包含的字节码指令，相当于实际机器的cpu
#### 4、32位jvm和64位jvm的最大堆内存分别是多少
 - 32位最大堆内存可以到2^32，4GB，实际小很多，不同操作系统不一样
 - 64位最大堆内存可以到2^64,是一个很大的数字，实际上可以指定100GB，有的操作系统可以指定1000GB
 - iny类型的长度在32位和64位是一样的4个字节
#### 5、Java运行时内存分类
 - 程序计数器，Java线程私有，类似操作系统计数器，行号指示器
 - 虚拟机栈（栈内存），Java线程私有，Java方法执行的内存模型
   - 每个方法执行的时候都会创建一个栈帧用于存储局部变量，操作数，动态链接，方法出口
   - 每个方法调用意味着一次入栈和出栈的过程
 - 本地方法栈，Java虚拟机栈类似，主要提供native方法额服务
 - 堆内存（线程共享），所有线程共享的一块区域，垃圾收集器管理的主要区域
   - 目前主要的垃圾回收算法都是分代收集算法，Java堆中细分新生代和老生代或者eden空间，from survivor空间，to survivor空间，默认新生代按照 8:1:1的比例分配
   - Java寻机的堆在物理上不连续的内存空间，只要逻辑上是连续的即可
 - 方法区（线程共享），用于存储虚拟机加载的类信息，常量，静态变量，及时编译器编译后的代码等数据
   - 方法区还有一个名字是非堆内存
   - 运行时常量池，是方法区的一部分，用于存放各种字面量和符合引用
#### 6、直接内存是不是虚拟机运行时数据区的一部分
 - 直接内存（direct memory）,不是虚拟机的一部分，不受Java堆大小的限制，受本机总内存大小限制
 - 直接内存，可能出现内存溢出异常
#### 7、直接内存与堆内存比较
 - 直接内存申请空间耗费更高的性能，避免频繁申请
 - 直接内存io读写的性能要优于普通的堆内存，
#### 8、Java8中元空间替代了老生代
 - 字符串常量存放在了堆内存中，
#### 9、为什么废弃永久代
 - 实际使用中永久代经常出现内存不够用，或发生内存泄漏，爆出异常
   - 字符串存放在永久代中，容易出现性能问题和内存溢出
   - 类方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易串行永久代溢出，太大容易导致老年代溢出
 - 永久代会为GC带来不必要的复杂度，回收效率偏低
#### 10、Java内存堆和栈区别
 - 堆内存存储基本类型的变量和对象的引用变量，存储Java中的所有变量
 - 栈内存归属单个线程，每个线程会有一个栈内存，变量只在所属线程中可见，线程的私用内存，
 - 如果栈内存没有可用的空间存储方法调用和局部变量，jvm会抛出栈溢出，
 - 栈内存要远小于堆内存，递归可能导致栈内存迅速充满
#### 11、Java对象的创建过程
 - 检测是否可以在常量池中定位到一个类的符号引用，检测这个类是否被加载和解析，初始化化过，如果没有执行加载
 - 为对象分配内存空间
   - 内存空间规整，虚拟机只需要移动指针即可
   - 内存不规整，虚拟机需要维护一个列表，记录那些内存可用，分配内存的时候需要找到一个可用内存空间，空闲列表
 - 负载分配内存的时候回出现内存抢占的问题，就是一个分配完还没有修改指针另一个也修改了
   - 采用同步，cas的方式
   - 预分配内存，防止冲突，互不干扰，可以通过参数决定是否使用
 - 为分配空间初始化零值，保证还没有初始化就可以使用
 - 对对象进行其他设置，如对象的头，所属类，元数据，hashcode，gc的年龄等
 - 执行init方法，就是构造方法，初始化对象
#### 12、对象的内存布局
 - 对象头，存储对象自身的运行时数据，如哈希吗，GC分代年龄，锁状态标志，线程持有的锁，类型指针，执行类元数据
 - 实例数据
 - 对象填充，为了对齐
#### 13、对象如何定位访问
 - 句柄定位，Java堆中会画出一个内存来作为句柄池，reference中存储对象的句柄地址，句柄中包含具体信息
 - 直接指针访问，reference中存储对象的指针数据
#### 14、两种访问方式的对比
 - 使用句柄访问，就是reference中的地址不会改变，在对象移动时只需要修改句柄就行
 - 直接指针访问速度快，减少了一次转化
 - 目前主要使用的虚拟机sun hotspot使用的第二种方式
#### 15、有哪些内存溢出异常
 - Java堆溢出
 - 虚拟机栈和本地方法栈溢出，栈溢出不是内存溢出
 - 运行时常量池溢出 jdk6中会出现，jdk7中移入了堆
 - 方法区的内存溢出，jdk7会出现，jdk8移除了
 - 元数据区的内存溢出，jdk8中，相当于方法区内存溢出
 - 本机直接内存溢出
#### 16、当出现了内存溢出，你怎么排错
 - 控制台的错误日志
 - 使用jdk自带的jvisualvm工具查看西永的堆栈日志
 - 定位出内存溢出的空间：堆，栈，永久代
   - 如果是堆内存，是否创建了超大的对象
   - 如果是栈内存，是否超大对象或死循环
#### 17、Java中会出现内存泄漏吗
 - 理论是不会出现的，但是一些可能出现无用但可达的对象，不能被GC回收
 - netty的直接内存可能出现泄漏
#### 18、Java直接内存不会被回收吗，在jvm持有对象被回收之后
#### 19、finalize()什么时候调用，目的是什么
 - 通常建议在这个方法中释放改对象持有的资源，堆外内存，远程连接
 - 一般情况下，不建议重写
 - 对于一个对象，改方法有仅被调用一次
#### 20、判断一个对象是否死去
 - 引用计数，
 - 可达性分析，可以解决循环引用
#### 21、Java语言中的GC root
 - 虚拟机栈中的引用的对象
 - 方法区中的类静态属性引用对象
 - 方法区中常量引用的对象
 - 本地方法栈中引用的对象
#### 22、方法区是否被回收，
 - 可以被回收，只要释放废弃的常量和无用的类
 - 该类所有实例被回收
 - 加载该类的classLOader已经被回收
 - 该类对用的对象没有任何地方引用，无法再任何地方利用反射访问
#### 23、Java的引用类型
 - 强引用
 - 软引用 内存不足时回收
 - 弱引用 一旦发现就会被回收
 - 虚引用 随时都会回收
#### 24、为什么需要不同的引用类型
 - 解决缓存
 - 解决oom问题
 - java对于我们不能控制对象的回收，一种妥协的做法
#### 25、jvm垃圾回收算法
 - 标记清除
 - 标记整理
 - 复制算法
 - 分代收集
#### 26、什么是安全点
 - 在安全点jvm可以进行一些操作，比如GC
 - 循环的末尾
 - 方法返回前
 - 调用方法的call之后
 - 抛出异常的位置
#### 27、什么是oopmap状态
#### 28、jvm如何中断线程
 - 主动式，主动式jvm设置一个全局变量，线程区按照某种策略检查这个变量，一旦发现是安全点就主动挂起
 - 被动式，就是接受到信号，被动挂起，不考虑线程的状态
#### 29、什么是安全区域
 - 安全区域是指一段代码片中，引用关系不会发生变化，在这个区域任何地方GC都是安全的
#### 30、jvm垃圾收集器有哪些
 - 新生代，serial收集器。parnew收集器，parallel scavenge收集器
 - 老生代。serial old收集器，parallel old收集器，cms收集器
 - 新生代+老年代收集器，G1收集器，ZGC收集器
#### 31、对象分配规则是什么
 - 对象优先分配在eden区，顺序，新生代（Eden，survivor0，survivor1），老年代
 - 大对象直接进入老年代
 - 长期存活的对象进入老年代
 - 动态判断对象年龄
 - 空间分配担保
#### 32、为什么需要两个survivor区
 -
#### 33、什么时候出现young gc
#### 34、什么时候出现full gc
#### 35、jdk的命令号公交哪些可以监控虚拟机
 - jps，虚拟机进程状况工具
 - jstat，虚拟机统计信息监控工具
 - jinfo，java配置信息工具
 - jmap，Java内存映射工具
 - jhat，虚拟机堆转储快照分析工具
 - jstack，Java堆栈跟踪工具
 - hsdis,jit生成代码反编译
#### 36、jdk的可视化工具有哪些可以监控虚拟机
 - jconsole，Java监视与管理控制台
 - visualVm，多合一故障处理工具
 - mat，内存分析工具
 - gchisto，分析gc日志工具
#### 37、怎么获取Java程序使用的内存
 - runtime类可以获取，剩余，总，最大内存字节数
#### 38、常用的GC优化配置
 - xms，初始化化堆内存大小
 - xmx 堆内存最大值
 - xmn 堆内存最小值
 - xx:permSize 初始化永久代大小
 - xx:maxpermsize 永久比值代最大容量
 - xx:survivorRatio 设置年轻代中eden区与survivor区的比值
 - xx:xmn 设置年轻代大小
#### 39、如何排除线程full gc频繁的问题
#### 40、jvm的永久代中会发生垃圾回收吗
 - young gc不会出现在永久代
 - 但是如果永久代超过阈值会发生fullgc
#### 41、类加载器是什么
 - 类加载器负责读取Java字节码，并转化为class类的实例
 - 每个类都是这个class实例创建对象
#### 42、类加载发生的时机是什么时候
 - 遇到new，getstatic，putstatic，invokestatic，这四条指令的时候，如果累还没有初始化
 - 使用reflect对类进行反射调用的时候
 - 当一个类的子类初始化的时候，父类也同样会被加载
 - main方法的类
#### 43、类加载器如何加载class文件
 - 加载，验证，准备，解析，初始化，使用，卸载
#### 44、类的静态属性是和类一起存放，那么多次修改同一个静态变量，在不同实例中取到的值都是一样的
#### 45、类在加载阶段做了什么
#### 46、类在验证阶段做了什么
#### 47、类在解析阶段做了什么
#### 48、类在初始化阶段做了什么
#### 49、什么是双亲委派模型
#### 50、Java虚拟机是如何判断两个Java类是相同的
#### 51、双亲委派模型的工作过程
#### 52、为什么优先使用父classLoader加载类
#### 53、什么是破坏双亲委托模型
