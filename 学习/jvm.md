### jvm学习笔记

#### 1、什么是虚拟机
 - jvm实际上就是将操作系统的底层实现和Java字节码之间进行了一次解耦
#### 2、jvm有哪些部分组成
 - 类加载器
 - 运行时数据区
   - 方法区
   - 堆
   - Java栈
   - 本地方法栈
   - 程序计数器
 - 执行引擎
 - 本地接口
 - 本地库
#### 3、执行引擎的作用
 - 执行引擎负责执行class文件中包含的字节码指令，相当于实际机器的cpu
#### 4、32位jvm和64位jvm的最大堆内存分别是多少
 - 32位最大堆内存可以到2^32，4GB，实际小很多，不同操作系统不一样
 - 64位最大堆内存可以到2^64,是一个很大的数字，实际上可以指定100GB，有的操作系统可以指定1000GB
 - iny类型的长度在32位和64位是一样的4个字节
#### 5、Java运行时内存分类
 - 程序计数器，Java线程私有，类似操作系统计数器，行号指示器
 - 虚拟机栈（栈内存），Java线程私有，Java方法执行的内存模型
   - 每个方法执行的时候都会创建一个栈帧用于存储局部变量，操作数，动态链接，方法出口
   - 每个方法调用意味着一次入栈和出栈的过程
 - 本地方法栈，Java虚拟机栈类似，主要提供native方法额服务
 - 堆内存（线程共享），所有线程共享的一块区域，垃圾收集器管理的主要区域
   - 目前主要的垃圾回收算法都是分代收集算法，Java堆中细分新生代和老生代或者eden空间，from survivor空间，to survivor空间，默认新生代按照 8:1:1的比例分配
   - Java寻机的堆在物理上不连续的内存空间，只要逻辑上是连续的即可
 - 方法区（线程共享），用于存储虚拟机加载的类信息，常量，静态变量，及时编译器编译后的代码等数据
   - 方法区还有一个名字是非堆内存
   - 运行时常量池，是方法区的一部分，用于存放各种字面量和符合引用
#### 6、直接内存是不是虚拟机运行时数据区的一部分
 - 直接内存（direct memory）,不是虚拟机的一部分，不受Java堆大小的限制，受本机总内存大小限制
 - 直接内存，可能出现内存溢出异常
#### 7、直接内存与堆内存比较
 - 直接内存申请空间耗费更高的性能，避免频繁申请
 - 直接内存io读写的性能要优于普通的堆内存，
#### 8、Java8中元空间替代了老生代
 - 字符串常量存放在了堆内存中，
#### 9、为什么废弃永久代
 - 实际使用中永久代经常出现内存不够用，或发生内存泄漏，爆出异常
   - 字符串存放在永久代中，容易出现性能问题和内存溢出
   - 类方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易串行永久代溢出，太大容易导致老年代溢出
 - 永久代会为GC带来不必要的复杂度，回收效率偏低
#### 10、Java内存堆和栈区别
 - 堆内存存储基本类型的变量和对象的引用变量，存储Java中的所有变量
 - 栈内存归属单个线程，每个线程会有一个栈内存，变量只在所属线程中可见，线程的私用内存，
 - 如果栈内存没有可用的空间存储方法调用和局部变量，jvm会抛出栈溢出，
 - 栈内存要远小于堆内存，递归可能导致栈内存迅速充满
#### 11、Java对象的创建过程
 - 检测是否可以在常量池中定位到一个类的符号引用，检测这个类是否被加载和解析，初始化化过，如果没有执行加载
 - 为对象分配内存空间
   - 内存空间规整，虚拟机只需要移动指针即可
   - 内存不规整，虚拟机需要维护一个列表，记录那些内存可用，分配内存的时候需要找到一个可用内存空间，空闲列表
 - 负载分配内存的时候回出现内存抢占的问题，就是一个分配完还没有修改指针另一个也修改了
   - 采用同步，cas的方式
   - 预分配内存，防止冲突，互不干扰，可以通过参数决定是否使用
 - 为分配空间初始化零值，保证还没有初始化就可以使用
 - 对对象进行其他设置，如对象的头，所属类，元数据，hashcode，gc的年龄等
 - 执行init方法，就是构造方法，初始化对象
#### 12、对象的内存布局
 - 对象头，存储对象自身的运行时数据，如哈希吗，GC分代年龄，锁状态标志，线程持有的锁，类型指针，执行类元数据
 - 实例数据
 - 对象填充，为了对齐
#### 13、对象如何定位访问
 - 句柄定位，Java堆中会画出一个内存来作为句柄池，reference中存储对象的句柄地址，句柄中包含具体信息
 - 直接指针访问，reference中存储对象的指针数据
#### 14、两种访问方式的对比
 -
